# usbipClient

* * *

## 目前为止遇到的问题及解决办法

* * *
### 1.热插拔处理(hotplug)

要求：需要系统自动识别USB信息的插入和拔出.
使用netlink和udev配合来完成.
USB设备发生变化时，首先由kernel发现，然后使用netlink通知udev.
这里需要做的工作是：在用户层创建netlink套接字，用于接收kernel发送的USB设备信息.
详细可以参考[这里](add@/devices/pci0000:00/0000:00:1d.0/usb5/5-1).

* * *
### 2.对于从kernel接收的USB信息进行处理提取信息

* * *
### 3.创建线程处理USB信息时，出现线程竞争

1，强迫主线程休眠，子线程先运行.
2，使用临时变量接收buf内容，不干扰线程运行顺序.

* * *
### 4.未完成工作

* 1.将处理结果发送到server.
* 3.从usbip-utils抽取代码.
* 2.优化代码，使其更加健壮.

### 5. 3月2日更新
* 1.要求功能基本实现.
* 2.剩余的问题:
    * 2.1 线程管理问题，像线程优先级，线程同步(对关键数据进行加锁保护).
    * 2.2 对使用的内存资源的free，防止内存泄漏.
    * 2.3 对usbip-utils进行关键代码的抽取，避免调用system()，包括usbip-bind()和usbip-unbind().

### 6. 3月16日更新
* 1.重新对C/S结构进行了处理，优化之前软件结构的冗余，减少了C/S之间不必要的信息交流。现在C只对S发送bind到usb-host的设备号，不接收S的消息。而S只是处理C发送的设备号，不给C发送移除的设备号，只是在S端清理attach后产生的文件，方便设备的下次接入挂载。
* 2.因为涉及使用usbip的userspace-utils，例如bind(), unbind(), attach(), detach()等操作，但是使用system()的话，又会因为执行system()时产生的SIGINT导致程序执行时的不稳定，所以就把usbip的userspace-utils编译成动态库做出API，在程序中作为接口函数调用，但是同时也对接口函数进行了改造，使之更加适应程序的功能需要。

### 6. 3月23日更新
* 1.拿掉了动态库，尽管不是我的意思:-(.
